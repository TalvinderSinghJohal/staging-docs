---
title: Response Formatting for AI Gateway
description: The AI Gateway's Response Formatting feature provides powerful, flexible control over AI response structure and format, enabling applications to receive consistent, standardized outputs across all 7 AI providers. Through advanced transformation engines, strict compliance modes, and customizable formatting options, organizations can ensure their applications receive responses in exactly the format required, regardless of the underlying provider's native response structure.
---

## Overview

Response Formatting represents a critical integration capability that ensures consistent AI response structures across diverse provider ecosystems. By providing a unified response format while preserving provider-specific capabilities when needed, the AI Gateway enables applications to integrate with multiple AI providers without code changes or format adaptation logic.

### Key Capabilities

<Columns cols={2}>
  <Card title="Universal Format Standardization" icon="layers">
    Consistent OpenAI-compatible responses across all providers.
  </Card>
  <Card title="Strict Compliance Mode" icon="check-circle">
    Pure OpenAI compatibility for maximum portability.
  </Card>
  <Card title="Enhanced Format Mode" icon="settings">
    Provider-specific features preserved when beneficial.
  </Card>
  <Card title="Structured Output Support" icon="code">
    JSON schema validation and formatted responses.
  </Card>
  <Card title="Content Block Management" icon="folder">
    Advanced content organization and metadata.
  </Card>
  <Card title="Performance Metrics Integration" icon="activity">
    Response timing and processing information.
  </Card>
  <Card title="Error Format Standardization" icon="alert-triangle">
    Consistent error response structures.
  </Card>
</Columns>

### The Challenge It Solves

Without response formatting, applications must handle multiple response formats:

| Without AI Gateway | With Response Formatting |
|-------------------|-------------------------|
| 7 different response formats | 1 unified response format |
| Provider-specific parsing | Standard JSON structure |
| Custom error handling | Consistent error formats |
| Feature detection logic | Transparent feature access |
| Complex integration code | Simple API consumption |
| Breaking changes | Stable interface |

---

## How Response Formatting Works

### Provider Transformation

The AI Gateway employs sophisticated transformation engines that convert provider-native responses into standardized formats while preserving essential information and capabilities.

<Steps>
  <Step title="Provider Response">
    The raw response is received from the upstream AI provider in its native format.
  </Step>
  <Step title="Format Detection">
    The gateway automatically detects the provider and response format to determine the appropriate transformation logic.
  </Step>
  <Step title="Content Extraction">
    Relevant data, such as generated text, choices, and any provider-specific fields, are extracted from the native response.
  </Step>
  <Step title="Structure Normalization">
    The extracted content is reorganized into a consistent internal structure, aligning with the OpenAI schema.
  </Step>
  <Step title="Feature Mapping">
    Provider-specific features (e.g., function calls, tool outputs, citations) are mapped to standardized fields or extensions.
  </Step>
  <Step title="Metadata Preservation">
    Important metadata—such as model name, latency, and provider information—is retained and attached to the response.
  </Step>
  <Step title="OpenAI Format Assembly">
    The normalized content and metadata are assembled into a response that matches the OpenAI API format.
  </Step>
  <Step title="Validation & Quality Check">
    The assembled response is validated for schema compliance and checked for completeness and quality.
  </Step>
  <Step title="Standardized Response">
    The final, standardized response is returned to the client, ensuring compatibility and consistency across all providers.
  </Step>
</Steps>

### Compliance Modes

The gateway supports multiple formatting modes to balance compatibility with functionality:

#### Standard Mode (Default)
- OpenAI-compatible core structure
- Provider-specific enhancements preserved
- Extended metadata and features included
- Optimal balance of compatibility and functionality

#### Strict Compliance Mode
- Pure OpenAI specification compliance
- Provider extensions filtered out
- Maximum portability across systems
- Activated via `x-strict-open-ai-compliance: true` header

### Format Controls

#### Response Format Parameter
```json
{
  "response_format": {
    "type": "json_object"  // or "text" or "json_schema"
  }
}
```

#### JSON Schema Support
```json
{
  "response_format": {
    "type": "json_schema",
    "json_schema": {
      "name": "response_schema",
      "schema": {
        "type": "object",
        "properties": {
          "answer": {"type": "string"},
          "confidence": {"type": "number"}
        }
      }
    }
  }
}
```

---

## Business Benefits

### Application Integration

#### Simplified Development
- **90% Reduction in Integration Code**: Single response format across all providers
- **Zero Provider-Specific Logic**: Applications work with any provider transparently
- **Faster Development Cycles**: No need to understand provider differences
- **Reduced Testing Overhead**: Test once, works everywhere

#### Code Maintainability
```typescript
// Before (Without Response Formatting)
switch (provider) {
  case 'openai':
    return parseOpenAIResponse(response);
  case 'anthropic':
    return parseAnthropicResponse(response);
  case 'bedrock':
    return parseBedrockResponse(response);
  // ... handle 7 different formats
}

// After (With Response Formatting)
return response; // Always OpenAI-compatible format
```

### Development Efficiency

#### Team Productivity
- **75% Faster Feature Development**: Consistent interface accelerates development
- **50% Reduction in Bugs**: Fewer format-related errors
- **Unified Documentation**: Single format specification to learn
- **Cross-Team Consistency**: All teams use the same response structure

#### Development Metrics
| Metric | Without Formatting | With Formatting | Improvement |
|--------|------------------|----------------|-------------|
| Integration Time | 5-10 days | 1-2 days | 80% faster |
| Bug Rate | 15 per sprint | 3 per sprint | 80% reduction |
| Code Complexity | 500 LOC | 100 LOC | 80% simpler |
| Test Coverage | 60% | 95% | 58% increase |

### Operational Consistency

#### Monitoring and Logging
- **Unified Log Format**: Consistent response structures in logs
- **Standardized Metrics**: Common performance measurements
- **Error Correlation**: Consistent error formats for debugging
- **Audit Compliance**: Standardized response tracking

#### Quality Assurance
- **Predictable Testing**: Same test suite works across providers
- **Automated Validation**: Consistent response structure validation
- **Performance Benchmarking**: Apples-to-apples provider comparison
- **Error Rate Analysis**: Uniform error classification

### Future-Proofing

#### Provider Independence
- **Vendor Lock-in Avoidance**: Easy provider switching without code changes
- **New Provider Integration**: Instant compatibility with new providers
- **Technology Evolution**: Adapt to new AI capabilities transparently
- **Cost Optimization**: Switch providers based on pricing without integration work

#### Business Continuity
- **Resilience**: Continue operations even if preferred provider has issues
- **Flexibility**: Adapt to changing business requirements quickly
- **Innovation**: Experiment with new providers without risk
- **Compliance**: Meet changing regulatory requirements consistently

---

## Technical Architecture

### Response Transformation Engine

#### Core Transformation Class
```typescript
class ResponseTransformer {
  transformToOpenAI(
    response: ProviderResponse,
    provider: string,
    requestModel: string,
    strictCompliance: boolean = false
  ): OpenAIChatCompletionResponse {
    // Provider-specific transformation logic
    switch (provider) {
      case 'openai':
        return this.passThrough(response, 'openai');
      case 'anthropic':
        return this.transformAnthropic(response, strictCompliance);
      case 'bedrock':
        return this.transformBedrock(response, strictCompliance);
      // ... handle all 7 providers
    }
  }
}
```

### Format Standardization

#### Standard OpenAI Response Structure
```json
{
  "id": "chatcmpl-123",
  "object": "chat.completion",
  "created": 1677652288,
  "model": "gpt-4",
  "provider": "openai",
  "choices": [
    {
      "index": 0,
      "message": {
        "role": "assistant",
        "content": "Hello! How can I help you today?"
      },
      "finish_reason": "stop"
    }
  ],
  "usage": {
    "prompt_tokens": 9,
    "completion_tokens": 12,
    "total_tokens": 21
  }
}
```

#### Enhanced Format with Provider Extensions
```json
{
  "id": "msg-123",
  "object": "chat.completion", 
  "created": 1677652288,
  "model": "claude-3-sonnet",
  "provider": "anthropic",
  "choices": [
    {
      "index": 0,
      "message": {
        "role": "assistant",
        "content": "Hello! How can I help you today?",
        "content_blocks": [
          {
            "type": "text",
            "text": "Hello! How can I help you today?"
          }
        ]
      },
      "finish_reason": "stop"
    }
  ],
  "usage": {
    "prompt_tokens": 9,
    "completion_tokens": 12,
    "total_tokens": 21
  },
  "processing_time_ms": 250
}
```

### Compliance Framework

#### Strict Compliance Implementation
```typescript
interface ComplianceOptions {
  strictOpenAiCompliance: boolean;
  includeProviderExtensions: boolean;
  filterNonStandardFields: boolean;
  validateResponseSchema: boolean;
}

class ComplianceFilter {
  applyStrictCompliance(response: any): OpenAIChatCompletionResponse {
    // Remove all non-OpenAI standard fields
    return {
      id: response.id,
      object: 'chat.completion',
      created: response.created,
      model: response.model,
      choices: this.filterChoices(response.choices),
      usage: this.filterUsage(response.usage)
    };
  }
}
```

---

## Format Options

### Standard OpenAI Format

The default format provides OpenAI compatibility while preserving valuable provider-specific information.

#### Core Structure
- **Standard Fields**: `id`, `object`, `created`, `model`, `choices`, `usage`
- **Provider Identification**: `provider` field indicates source
- **Extended Metadata**: Performance metrics, content blocks, safety information
- **Tool Call Support**: Unified tool calling format across providers

### Enhanced Format

Enhanced format includes provider-specific capabilities that don't exist in the OpenAI specification.

#### Extended Capabilities
```typescript
interface EnhancedResponse extends OpenAIChatCompletionResponse {
  provider: string;
  processing_time_ms?: number;
  choices: EnhancedChoice[];
  usage?: EnhancedUsage;
  safety_ratings?: SafetyRating[];
  content_filter_results?: ContentFilter[];
}

interface EnhancedChoice {
  message?: {
    content_blocks?: ContentBlock[];
    thinking?: string;
    safety_ratings?: SafetyRating[];
  };
}
```

### Strict Compliance Mode

Pure OpenAI specification compliance for maximum portability.

#### Activation
```http
POST /v1/chat/completions
x-strict-open-ai-compliance: true
Content-Type: application/json

{
  "model": "claude-3-sonnet",
  "messages": [...]
}
```

#### Filtered Response
```json
{
  "id": "chatcmpl-123",
  "object": "chat.completion",
  "created": 1677652288,
  "model": "claude-3-sonnet",
  "choices": [
    {
      "index": 0,
      "message": {
        "role": "assistant", 
        "content": "Response text only"
      },
      "finish_reason": "stop"
    }
  ],
  "usage": {
    "prompt_tokens": 9,
    "completion_tokens": 12,
    "total_tokens": 21
  }
}
```

---

## Provider-Specific Handling

### Transformation Matrix

| Provider | Native Format | Transformation Complexity | Preserved Features | Compliance Support |
|----------|---------------|---------------------------|-------------------|-------------------|
| **OpenAI** | OpenAI Standard | None (pass-through) | All | Full |
| **Azure OpenAI** | OpenAI Standard | Minimal (provider tag) | All | Full |
| **Anthropic** | Claude Format | High | Content blocks, thinking | Full |
| **Bedrock** | Bedrock Format | High | Guardrails, safety | Full |
| **Google** | Gemini Format | Moderate | Safety ratings | Full |
| **Vertex AI** | Vertex Format | Moderate | Labels, metadata | Full |
| **Azure AI** | OpenAI Compatible | Minimal | Standard features | Full |

### Feature Adaptation

#### Provider-Specific Features Handling

##### Anthropic Features
```typescript
// Anthropic thinking content preservation
if (contentItem.type === 'thinking' && !strictCompliance) {
  contentBlocks.push({
    type: 'thinking',
    thinking: contentItem.text,
    processing_time_ms: contentItem.processing_time
  });
}
```

##### Bedrock Features  
```typescript
// Bedrock guardrail results preservation
if (response.guardrailResults && !strictCompliance) {
  enhancedResponse.guardrail_results = {
    action: response.guardrailResults.action,
    assessments: response.guardrailResults.assessments
  };
}
```

##### Google Features
```typescript
// Google safety ratings preservation
if (response.safetyRatings && !strictCompliance) {
  enhancedResponse.safety_ratings = response.safetyRatings.map(rating => ({
    category: rating.category,
    probability: rating.probability,
    blocked: rating.blocked
  }));
}
```

---

## Use Cases

### Enterprise Applications

#### Multi-Tenant SaaS Platform
- **Scenario**: Platform supporting multiple AI providers per tenant
- **Solution**: Unified response format across all tenant configurations
- **Benefit**: Single client SDK works for all tenants regardless of provider
- **Impact**: 80% reduction in SDK complexity, 60% faster client development

#### API Integration Layer
- **Scenario**: Enterprise API that abstracts multiple AI services
- **Solution**: Standardized response format for all downstream services
- **Benefit**: Consistent API contracts for internal and external consumers
- **Impact**: 90% reduction in documentation complexity, faster partner integration

#### Analytics and Monitoring Platform
- **Scenario**: Centralized monitoring across multiple AI providers
- **Solution**: Uniform response structure for consistent analytics
- **Benefit**: Single analytics pipeline handles all provider responses
- **Impact**: 70% reduction in data processing complexity

### Development Scenarios

#### Multi-Provider Applications
- **Scenario**: Application using different providers for different features
- **Solution**: Consistent response handling across all provider interactions
- **Benefit**: Unified error handling, logging, and response processing
- **Impact**: 50% reduction in application complexity

#### A/B Testing Frameworks
- **Scenario**: Testing multiple providers for performance comparison
- **Solution**: Standardized response format enables fair comparison
- **Benefit**: Identical test harnesses work across all providers
- **Impact**: 90% reduction in test infrastructure complexity

#### Development and Staging Environments
- **Scenario**: Different providers used across environment tiers
- **Solution**: Consistent response format ensures environment parity
- **Benefit**: Code works identically across all environments
- **Impact**: 95% reduction in environment-specific issues

---

## Configuration Options

### Global Configuration

#### Response Format Settings
```yaml
response_formatting:
  default_mode: "enhanced"  # "enhanced" | "strict" | "minimal"
  preserve_provider_metadata: true
  include_performance_metrics: true
  validate_schema: true
  filter_sensitive_data: true
```

### Request-Level Configuration

#### Per-Request Format Control
```http
POST /v1/chat/completions
x-strict-open-ai-compliance: true
x-include-metadata: false
x-filter-extensions: content_blocks,thinking

{
  "model": "gpt-4",
  "messages": [...],
  "response_format": {
    "type": "json_schema",
    "json_schema": {...}
  }
}
```

### Provider-Specific Settings

#### Custom Transformation Rules
```typescript
interface ProviderFormatConfig {
  provider: string;
  preserveFeatures: string[];
  filterFields: string[];
  customTransformations: TransformationRule[];
}

const anthropicConfig: ProviderFormatConfig = {
  provider: 'anthropic',
  preserveFeatures: ['thinking', 'content_blocks'],
  filterFields: ['internal_metadata'],
  customTransformations: [
    {
      field: 'stop_reason',
      transform: (value) => FINISH_REASON_MAP[value] || 'stop'
    }
  ]
};
```

---

## Best Practices

### Format Selection

#### When to Use Standard Mode
- **Multi-provider applications**: Need provider flexibility with features
- **Development environments**: Want full provider capabilities
- **Analytics platforms**: Require comprehensive response metadata
- **Custom integrations**: Benefit from provider-specific information

#### When to Use Strict Compliance Mode
- **Third-party integrations**: Working with existing OpenAI-compatible systems
- **Legacy applications**: Migrating from direct OpenAI integration
- **Standards compliance**: Regulatory or organizational requirements
- **Simple applications**: Don't need provider-specific features

### Response Handling

#### Robust Response Processing
```typescript
interface ResponseHandler {
  processResponse(response: OpenAIChatCompletionResponse): ProcessedResponse {
    // Always handle standard OpenAI fields
    const result = {
      content: response.choices[0]?.message?.content || '',
      usage: response.usage,
      provider: response.provider
    };

    // Optionally handle enhanced features
    const message = response.choices[0]?.message;
    if (message?.content_blocks) {
      result.contentBlocks = message.content_blocks;
    }
    
    if (message?.thinking) {
      result.thinking = message.thinking;
    }

    return result;
  }
}
```

### Error Handling

#### Consistent Error Processing
```typescript
interface StandardizedError {
  error: {
    type: string;
    code: string;
    message: string;
    provider: string;
    details?: any;
  };
}

// All providers return errors in this format
const handleError = (error: StandardizedError) => {
  console.error(`${error.error.provider} error: ${error.error.message}`);
  // Unified error handling logic
};
```

---

## Advanced Features

### Dynamic Format Adaptation

#### Context-Aware Formatting
```typescript
interface FormatContext {
  clientCapabilities: string[];
  applicationRequirements: FormatRequirement[];
  performanceConstraints: PerformanceLimit[];
}

class DynamicFormatter {
  adaptFormat(
    response: ProviderResponse,
    context: FormatContext
  ): FormattedResponse {
    // Adapt format based on client capabilities
    if (context.clientCapabilities.includes('enhanced_metadata')) {
      return this.enhancedFormat(response);
    }
    return this.standardFormat(response);
  }
}
```

### Custom Transformation Plugins

#### Extensible Format Pipeline
```typescript
interface FormatPlugin {
  name: string;
  transform(response: any, context: TransformContext): any;
  shouldApply(provider: string, mode: string): boolean;
}

class CustomMetadataPlugin implements FormatPlugin {
  name = 'custom_metadata';
  
  transform(response: any): any {
    return {
      ...response,
      custom_metadata: {
        processed_at: Date.now(),
        format_version: '2.0'
      }
    };
  }
  
  shouldApply(provider: string, mode: string): boolean {
    return mode === 'enhanced';
  }
}
```

### Schema Validation

#### Response Validation Framework
```typescript
interface ResponseValidator {
  validateOpenAICompliance(response: any): ValidationResult;
  validateCustomSchema(response: any, schema: JSONSchema): ValidationResult;
  validateProviderSpecific(response: any, provider: string): ValidationResult;
}

const validator = new ResponseValidator();
const result = validator.validateOpenAICompliance(response);
if (!result.valid) {
  throw new Error(`Invalid response format: ${result.errors.join(', ')}`);
}
```

---

## Troubleshooting

### Common Issues

#### Format Inconsistencies
- **Cause**: Provider returns unexpected response structure
- **Solution**: Check provider status, validate request format
- **Prevention**: Use response validation, monitor format compliance

#### Missing Provider Features
- **Cause**: Strict compliance mode filtering out provider capabilities
- **Solution**: Switch to standard mode or configure feature preservation
- **Prevention**: Understand feature requirements before enabling strict mode

#### Performance Impact
- **Cause**: Complex transformations for certain providers
- **Solution**: Use caching, optimize transformation logic
- **Prevention**: Monitor transformation performance, tune based on usage

### Debugging Format Issues

#### Response Format Validation
```bash
# Validate response format
curl -H "x-validate-format: true" \
     http://gateway/v1/chat/completions

# Debug format transformation
curl -H "x-debug-transformation: true" \
     http://gateway/v1/chat/completions

# Compare formats across providers
curl -H "x-format-comparison: true" \
     http://gateway/v1/chat/completions
```

#### Format Analysis Tools
```typescript
// Response format analyzer
class FormatAnalyzer {
  analyzeResponse(response: any): FormatAnalysis {
    return {
      compliance: this.checkOpenAICompliance(response),
      extensions: this.identifyExtensions(response),
      completeness: this.checkFieldCompleteness(response),
      performance: this.measureTransformationTime(response)
    };
  }
}
```